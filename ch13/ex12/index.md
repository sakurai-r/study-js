[マイクロタスク](https://developer.mozilla.org/ja/docs/Web/API/HTML_DOM_API/Microtask_guide#%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%BF%E3%82%B9%E3%82%AF)

最初、マイクロタスクとタスクの違いは小さいように見えます。どちらもキューに入れられ、適切なタイミングで実行される JavaScript のコードで構成されています。しかし、イベントループは反復が始まったときにキューに存在したタスクだけを次々と実行するのに対し、マイクロタスクのキューはとても異なる方法で処理されます。

主な違いは 2 つあります。

まず、タスクが終了するたびに、イベントループは、タスクが他の JavaScript コードに制御を返しているかどうかをチェックします。もしそうでなければ、マイクロタスクキューにあるすべてのマイクロタスクを実行します。マイクロタスクキューは、イベントや他のコールバックを処理した後を含め、イベントループの反復ごとに複数回処理されます。

次に、マイクロタスクが queueMicrotask() を呼び出してキューにさらにマイクロタスクを追加すると、それらの新しく追加されたマイクロタスクは次のタスクが実行される前に実行されます。これは、イベントループが、たとえ追加され続けても、キューに何も残らなくなるまでマイクロタスクを呼び続けるからです。

警告: マイクロタスクはそれ自身がさらにマイクロタスクをキューに入れることができ、イベントループはキューが空になるまでマイクロタスクを処理し続けるので、イベントループがマイクロタスクを延々と処理し続けるという現実的なリスクが存在します。再帰的にマイクロタスクを追加する方法には注意が必要です。

### 予想

Hello, world が出力された後無限ループになる。

### 結果

何も表示されずに無限ループになる。

```js
setTimeout(() => console.log("Hello, world!"), 1000);
// 1秒後にコールバック関数がタスクキューに追加される

async function longRunningButAsyncFunction() {
  while (true) {
    await null; // await によってマイクロタスクが無限に生成され続ける
  }
}

longRunningButAsyncFunction(); // マイクロタスクの処理が完了するまでタスクに追加されたコールバックは実行されないため、何も表示されずに無限ループになる。
```

[参照](https://zenn.dev/estra/books/js-async-promise-chain-event-loop/viewer/2-epasync-event-loop)
イベントループは基本的に次の４つのステップから構成されるが、最初のタスクが「スクリプトの評価」になっているため、`setTimeout`より先にマイクロタスクである`longRunningButAsyncFunction`が実行され無限ループに陥る。

1. スクリプトの評価: 関数本体であるかのように(例えば main() のように)、スクリプトを同期的に実行し、コールスタックが空になるまで実行する。
2. 単一のタスクの実行: タスクキューから最も古いタスクを選択してコールスタックが空になるまで実行する。
3. すべてのマイクロタスクの実行: マイクロタスクキューから最も古いマイクロタスクを選択してコールスタックが空になるまで実行し、マイクロタスクキューが空になるまで繰り返す。
4. UI のレンダリング更新: UI をレンダリング更新してステップ２に戻る。
